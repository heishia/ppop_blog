---
alwaysApply: true
---

# Cursor Rules for ppop_blog Project

## Language and Communication
- Always respond in Korean
- 주석은 한글로 작성, 코드 및 프린트 디버깅은 영어로 작성
- 인코딩 문제를 방지하기 위해 이모지 사용 금지

## File Organization
- 새로운 파일을 생성할 때는 이미 생성되어 있는 폴더의 의도에 맞게 판단한 뒤 배치
- 이미 같은 이름의 파일이 존재한다면 적합성에 따라 통합하거나 다른 명칭으로 수정해서 배치

## 기본 규칙

### 전역 에러 처리
- 모든 에러 처리는 `core.exceptions`에 정의된 커스텀 예외 클래스를 사용한다.
- 필요한 예외 클래스는 자동 import 한다.
- 외부 모듈의 에러를 직접 노출하지 않는다.

### 이모티콘 사용 금지
- 이모티콘 사용하지 않는다. (`print`, `log`, `docstring` 모두 포함)

### 타입 힌트 활용
- 함수, 클래스, 파라미터, 리턴 타입에는 가능한 한 타입 힌트를 명시한다.
- Any 타입은 불가피한 경우 외에는 사용하지 않는다.

### 주석 스타일
- 설명이 필요한 핵심 로직에만 최소한으로 작성한다.
- 주석보다 함수명과 변수명으로 의도를 드러내는 방식을 우선한다.
- 불필요한 "이 함수는 ~한다" 형태의 설명은 작성하지 않는다.

### 터미널 출력 최소화
- `print()`는 정말 필수적인 상황 외에는 사용하지 않는다.
- 터미널 로그는 반드시 `logging` 모듈을 통해 출력한다.
- 기본 로깅 설정은 `core/logger.py`를 따른다.

### Config 및 Env 활용
- 보안·환경별 값은 `.env`에 두고, `core/config.py`에서는 이를 로드한다.
- 코드 내에서 직접 민감정보(API KEY 등)를 하드코딩하지 않는다.

### Main 실행 방식
- `main.py`는 앱의 진입점 역할만 담당한다.
- 라우터 등록, 예외 핸들러 등록, 설정 로드만 포함한다.
- 실행 로직은 main 외부 함수로 분리한다.

### 네이밍 규칙
- 함수/변수명: `snake_case`
- 클래스명: `PascalCase`
- 파일/폴더명: 소문자 + 스네이크 케이스
- 상수: `UPPER_SNAKE_CASE`

### Requirements.txt
- 새로운 패키지를 추가할 경우 `requirements.txt`를 반드시 업데이트한다.
- 버전은 명시적으로 고정한다 (`==` 사용).

## 작성 규칙

### 함수
- 한 함수 = 하나의 책임 (SRP 원칙)
- 네이밍은 명사+목적어 형태로 기능을 명확히 표현한다.
- 예) `load_data()`, `parse_user_input()`
- 함수는 외부 입출력(IO)보다는 로직 중심으로 작성한다.

### 클래스
- 하나의 역할(주제)만 담당하도록 설계한다.
- 데이터의 소유권이 명확해야 한다.
- 역할이 다르다면 클래스를 분리한다.
- 클래스 내부에서 외부 의존성을 최소화한다.

### 실행부
- 항상 파일의 맨 하단에 위치한다.
- 실행부는 "흐름"만 제어한다.
- 세부 로직은 함수나 클래스 내부로 분리한다.

## Utils Functions Management (중요)

### 공통 원칙

- `backend/utils` 폴더에는 **모든 프로젝트에서 재사용 가능한 순수 함수**만 둔다.
- `core`의 설정, 로거, 예외 등 인프라 코드에 의존하지 않는다.
- 가능한 한 부작용(side effect)이 없는 순수 함수로 작성한다.
- 중복되는 로직을 새로 작성하지 말고, 이미 존재하는 유틸 함수를 import하여 사용한다.
- 타입 힌트 필수: 모든 함수에 타입 힌트를 명시
- 문서화: 각 함수에 docstring을 작성

### Import 규칙

- `utils`의 함수는 반드시 명시적 import로 불러온다.
- 예) `from backend.utils.time_utils import now_str`
- 자동 완성 시 동일 기능이 중복될 경우 `utils` 버전을 우선 선택한다.

### 함수 설계 원칙

- 단일 기능에 집중하고, 다른 레이어(core, features)에 의존하지 않는다.
- 입력값 검증, 문자열 처리, 파일 입출력, 시간 계산 등 **보조 역할 로직만 포함**한다.
- 외부 상태나 환경 변수, DB, 네트워크 요청 등은 사용하지 않는다.
- 반환값은 명확하고 예측 가능해야 한다.

### 파일 구성

| 파일명 | 역할 |
| --- | --- |
| `string_utils.py` | 문자열 변환, 슬러그, ID 생성 등 |
| `time_utils.py` | 현재 시각, 포맷 변환, 시간 차이 계산 |
| `validation_utils.py` | 이메일, 전화번호, 비밀번호 등 입력 검증 |
| `hash_utils.py` | 해시 생성, 비교, 토큰 생성 |
| `file_utils.py` | 파일/폴더 생성, 읽기/쓰기 |
| `json_utils.py` | JSON 직렬화/역직렬화, 안전 변환 |
| `env_utils.py` | 환경 변수 로드 및 접근 |
| `math_utils.py` | 단순 수학 계산, 비율, 반올림 등 |

### 사용 예시

- 문자열 변환 시 수동 regex 대신 `string_utils.slugify()` 사용
- 현재 시간 문자열은 `datetime.now()` 대신 `time_utils.now_str()` 사용

```python
# 올바른 예시
from backend.utils.string_utils import slugify
from backend.utils.time_utils import now_str

# 문자열 변환 시 수동 regex 대신 utils 함수 사용
slug = slugify("Hello World")  # "hello-world"

# 현재 시간 문자열은 datetime.now() 대신 utils 함수 사용
current_time = now_str()

# 잘못된 예시 (각 서비스에 중복 구현 금지)
# service1.py, service2.py에 동일한 slugify 함수가 각각 존재하면 안됨
```

## Development Environment
- Windows PowerShell 환경에서 작업 중이므로 터미널 명령어는 PowerShell 형식으로 제공

## Module Structure
- 각 기능 모듈은 `router.py`, `schemas.py`, `service.py`로 구성
- `main.py`는 앱의 진입점 역할만 담당 (라우터 등록, 예외 핸들러 등록, config 로드)
